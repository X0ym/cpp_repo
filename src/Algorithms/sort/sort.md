
# 快排
**算法思想**：分治
算法步骤：
1. 在待排序表 `p[1...n]` 中确定分界点 x ：可选左端点，中间点，右端点，或者随机选取分界点
2. 调整区间（一般 partition 函数）：使得 `p[1...k-1]` 都是小于x 的，`p[k+1...n]` 都是大于等于 x 的
3. 递归处理左右两段，直至每部分内只有一个元素或为空为止

**稳定性**：不稳定，因为在调整范围的时候，相等的元素会被交换位置；
时间复杂度：一般情况下为 O(NlogN)，最坏情况下时间复杂度退化到 O(N)

注意点
1）注意边界
递归处理 `quickSort(q,l,i-1); quickSort(q,i,r);` 时，分界点x不能取到左边界 `q[l]`，可取 `q[r]`，`q[(l+r+1)/2]`，`q[l]` 和 `q[(l+r)/2]` 不能取
2）递归处理 `quickSort(q,l,j);quickSort(q,j+1,r);` 时，分界点 x 不能取右边界 `q[r]`，可取 `q[l]`，`q[(l+r)/2]`，`q[r`] 和 `q[(l+r+1)/2]` 不能取
3）swap 函数，java 语言需要自己写


快排的核心在于如何划分区间
1）hua

C++ 
```cpp

```

# 归并排序

# 插入排序

