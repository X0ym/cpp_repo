# 最短路

概念说明
1. n 为图中结点数，m 为图中边的数目
2. s 为最短路的源点
3. D(u) 为 s 点到 u 点的**实际**最短路径
4. dis(u) 为 s 点到 u 点的**估计**最短路径。任何时候都有 dis(u)
>= D(u)。当最短路算法终止时，dis(u) = D(u)
5. w(u, v) 为 (u, v) 这一条边的边权

# dijkstra 算法

将结点分成两个集合：
1）已确定最短路径的点集（记为 S），未确定最短路径的点集（记为 T）

辅助数据
1）dis：记录源点到各顶点当前的最短路径，初始时，dis[s] = 0,

算法步骤：
1. 初始化：dis(s) = 0，其他点的 dis 均为正无穷大
2. 从集合 T 中，选取一个最短路径长度最小的结点 j（使得 dis[j] = min{dis[i], i ∈ T}，此时 j 就是当前从源点 s 出发的最短路径的终点），移入集合 S
3. 对加入集合的结点的所有出边执行松弛操作
4. 重复执行 2，3，直到 T 为空（执行 n 次）

Dijkstra 算法时间复杂度
存在多种方式来维护第2步操作中最短路径长度最小的结点，导致算法时间复杂度存在差异。
1. 朴素方法（暴力）：在集合 T 中暴力寻找最短路径长度最小的结点，时间复杂度为 O(n^2)，操作3的时间复杂度为 O(m)，总时间复杂度为 O(n^2)。
2. 二叉堆：时间复杂度为 O((n + m)logn) = O(mlogn)
3. 优先队列：同一个点被更新多次，同一个点被更新多次，而优先队列中插入的元素不能删除，也不能修改，只能留在优先队列中，时间复杂度为 
O(mlogm)
4. Fibonacci 堆，时间复杂度为 O(nlogn + m)，时间复杂度最优但不易实现，且效率优势不够大，较少使用。
5. 线段树：时间复杂度 O(mlogn)

## 正确性证明
参考：[dijkstra 正确性证明](https://oi-wiki.org/graph/shortest-path/#%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E)

## 朴素 dijkstra 算法
时间复杂度 O(N^2)
```cpp
const int maxn = 100010;

struct edge {
  int v, w;
};

vector<edge> e[maxn]; // 邻接表存图
int dis[maxn], vis[maxn];

// 朴素 dijkstra - O(n^2)
void dijkstra(int n, int s)
{
    // 初始化 dis
    memset(dis, 0x3f, sizeof(dis));
    dis[s] = 0;

    for (int i = 1; i <= n; i ++)
    {
        int u = 0, mind = 0x3f3f3f3f; 
        // 在未确定最短路的点，寻找距离最小的点
        for (int j = 1; j <= n; j ++)
            if (!vis[j] && dis[j] < mind)
                u = j, mind = dis[j];
        
        vis[u] = 1;

        // 对 u 的所有出边执行松弛操作
        for (auto ed : e[u])
        {
            int v = ed.v, w = ed.w;
            if (dis[v] > dis[u] + w) dis[v] = dis[u] + w;
        }
    }
}
```

`dist[i] == 0x3f3f3f3f` 说明源点 s 到结点 i 不存在最短路


## 优先队列实现
时间复杂度 O(mlogm)

```cpp
const int maxn = 100010;

struct edge {
  int v, w;
};

struct node {
  int dis, u;

  bool operator>(const node& a) const { return dis > a.dis; }
};

vector<edge> e[maxn];
int dis[maxn], vis[maxn];
priority_queue<node, vector<node>, greater<node> > q;

void dijkstra(int n, int s) 
{
    memset(dis, 63, sizeof(dis));
    dis[s] = 0;
    q.push({0, s});
    while (!q.empty())
    {
        int u = q.top().u;
        q.pop();
        if (vis[u])
            continue;
        vis[u] = 1;
        for (auto ed : e[u])
        {
            int v = ed.v, w = ed.w;
            if (dis[v] > dis[u] + w)
            {
                dis[v] = dis[u] + w;
                q.push({dis[v], v});
            }
        }
    }
}
```

# Bellman-Ford 算法
Bellman–Ford 算法是一种基于松弛（relax）操作的最短路算法，可以求出有负权的图的最短路，并可以对最短路不存在的情况进行判断。

松弛操作：
对于边 (u, v)，松弛操作为 `dis(v) = min(dis(v), dis(u) + w(u, v))`

Bellman-Ford 算法：
1. 初始化：
2. 不断对图中每一条边进行松弛，当一次循环中没有成功的松弛操作时，算法停止。最多循环 n 次



时间复杂度为 O(nm)

每次循环是 O(m)，最多循环 n 次。
1. 最短路存在。一次松弛操作可使最短路的边数至少 +1，而最短路的边数最多为 n - 1。因此整个算法最多执行 n - 1 轮松弛操作。总时间复杂度为 O(nm)
2. 存在负环。如果从 S 点出发，如果第 n 轮循环时仍存在能松弛的边，说明从 S 出发能够抵达一个负环。

注意：
负环判断中存在的常见误区：以 S 点为源点执行 Bellman-Ford 算法时，如果没有存在负环的结果，只能说明从 S 点出发不能抵达一个负环，而不能说明图上不存在负环。

判断图中是否存在负环？建立一个超级源点，与图中每个结点连一条权值为 0 的边，然后以超级源点为起点执行 Bellman-Ford 算法。

## 实现
时间复杂度：O(nm)
```cpp

```

# SPFA
